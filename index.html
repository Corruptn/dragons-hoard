<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragon's Hoard Slot Machine</title>
    <style>
        body {
            font-family: 'Cinzel', serif;
            text-align: center;
            background: url('https://www.transparenttextures.com/patterns/parchment.png') #2b2b2b;
            color: #d4a017;
            margin: 0;
            padding: 20px;
        }
        h1 {
            font-size: 36px;
            margin: 10px 0;
        }
        #slot-machine {
            display: grid;
            grid-template-rows: repeat(3, 100px);
            grid-template-columns: repeat(5, 100px);
            gap: 5px;
            margin: 20px auto;
            width: 520px;
            background: linear-gradient(135deg, #1a0f07 0%, #3d2a17 100%);
            padding: 10px;
            border: 8px solid #d4a017;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(212, 160, 23, 0.8), inset 0 0 15px rgba(212, 160, 23, 0.5);
            position: relative;
        }
        #slot-machine::before {
            content: "üêâ";
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            color: #d4a017;
            text-shadow: 0 0 10px #ff0000;
        }
        .reel {
            font-size: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: url('https://www.transparenttextures.com/patterns/paper.png') #fff9e6;
            color: #000;
            border: 3px solid #8b5a2b;
            border-radius: 10px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }
        .shield span {
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
        }
        .jackpot::after {
            content: '‚òÖ';
            font-size: 20px;
            color: #ffd700;
            position: absolute;
            top: 5px;
            right: 5px;
            text-shadow: 0 0 5px #ff0000;
        }
        .spinning {
            animation: spin 0.1s infinite linear;
        }
        @keyframes spin {
            0% { transform: translateY(0); opacity: 1; }
            50% { transform: translateY(-50px); opacity: 0.5; }
            100% { transform: translateY(-100px); opacity: 0; }
        }
        .blank-replace {
            animation: poof 0.6s ease-in-out;
        }
        @keyframes poof {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .win-replace {
            animation: drop 0.6s ease-in-out;
        }
        @keyframes drop {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            30% { transform: translateY(-20px) scale(1.2); opacity: 0.8; }
            60% { transform: translateY(100px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        .win {
            animation: glow 1.5s ease-in-out 2;
        }
        @keyframes glow {
            0% { background-color: #fff9e6; box-shadow: 0 0 5px #ffd700; }
            50% { background-color: #ffd700; box-shadow: 0 0 20px #ffd700; }
            100% { background-color: #fff9e6; box-shadow: 0 0 5px #ffd700; }
        }
        #controls {
            margin: 20px;
        }
        #result, #balance {
            font-size: 24px;
            margin: 10px;
            color: #fff;
            text-shadow: 0 0 5px #d4a017;
        }
        button {
            padding: 12px 24px;
            font-size: 18px;
            font-family: 'Cinzel', serif;
            background: linear-gradient(#d4a017, #b8860b);
            border: 3px solid #8b5a2b;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(212, 160, 23, 0.5);
            transition: all 0.3s ease;
        }
        button:hover:not(:disabled) {
            background: linear-gradient(#e6b923, #d4a017);
            box-shadow: 0 0 15px #ffd700;
        }
        button:disabled {
            background: linear-gradient(#8b5a2b, #5c4033);
            cursor: not-allowed;
            opacity: 0.6;
        }
        #odds, #payouts {
            margin: 20px auto;
            width: 540px;
            display: flex;
            justify-content: space-between;
            font-size: 16px;
        }
        .odds-item, .payout-item {
            background: linear-gradient(#3d2a17, #1a0f07);
            padding: 10px;
            border: 2px solid #d4a017;
            border-radius: 5px;
            width: 80px;
            color: #d4a017;
            box-shadow: inset 0 0 5px rgba(212, 160, 23, 0.5);
            text-align: left;
            font-size: 12px;
        }
        .no-link {
            color: #d4a017 !important;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            text-decoration: none !important;
            -webkit-text-decoration: none !important;
            pointer-events: none;
        }
        a[href^="tel"] {
            color: inherit !important;
            text-decoration: none !important;
            -webkit-text-decoration: none !important;
        }
        .payline {
            position: absolute;
            background: rgba(255, 0, 0, 0.8);
            height: 6px;
            z-index: 20;
            opacity: 1;
            transition: opacity 0.3s ease-out;
        }
        .payline.fade-out {
            opacity: 0;
        }
        @media (max-width: 430px) {
            body {
                padding: 5px;
                min-height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: center;
                -webkit-user-select: none;
                overflow-x: hidden;
            }
            h1 {
                font-size: 5.5vw;
                white-space: nowrap;
                padding: 5px 10px;
            }
            #slot-machine {
                grid-template-rows: repeat(3, 16vw);
                grid-template-columns: repeat(5, 16vw);
                gap: 1vw;
                margin: 5px auto;
                width: 85vw;
                padding: 2vw;
                border: 1.2vw solid #d4a017;
                border-radius: 2vw;
                box-shadow: 0 0 3vw rgba(212, 160, 23, 0.8), inset 0 0 2vw rgba(212, 160, 23, 0.5);
                -webkit-tap-highlight-color: transparent;
            }
            #slot-machine::before {
                top: -4vw;
                font-size: 5vw;
                text-shadow: 0 0 1.5vw #ff0000;
            }
            .reel {
                font-size: 9vw;
                border: 0.5vw solid #8b5a2b;
                border-radius: 1vw;
                box-shadow: inset 0 0 0.8vw rgba(0, 0, 0, 0.5);
            }
            .shield span {
                text-shadow: 0.3vw 0.3vw 0 #000, -0.3vw -0.3vw 0 #000, 0.3vw -0.3vw 0 #000, -0.3vw 0.3vw 0 #000;
            }
            .jackpot::after {
                font-size: 2.5vw;
                top: 0.8vw;
                right: 0.8vw;
                text-shadow: 0 0 0.8vw #ff0000;
            }
            @keyframes spin {
                0% { transform: translateY(0); opacity: 1; }
                50% { transform: translateY(-8vw); opacity: 0.5; }
                100% { transform: translateY(-16vw); opacity: 0; }
            }
            @keyframes drop {
                0% { transform: translateY(0) scale(1); opacity: 1; }
                30% { transform: translateY(-3vw) scale(1.2); opacity: 0.8; }
                60% { transform: translateY(16vw); opacity: 0; }
                100% { transform: translateY(0); opacity: 1; }
            }
            @keyframes glow {
                0% { background-color: #fff9e6; box-shadow: 0 0 0.8vw #ffd700; }
                50% { background-color: #ffd700; box-shadow: 0 0 3vw #ffd700; }
                100% { background-color: #fff9e6; box-shadow: 0 0 0.8vw #ffd700; }
            }
            #controls {
                margin: 5px;
            }
            #result, #balance {
                font-size: 3.5vw;
                margin: 5px;
            }
            button {
                padding: 1.5vw 3vw;
                font-size: 2.5vw;
                border: 0.5vw solid #8b5a2b;
                border-radius: 1vw;
                box-shadow: 0 0 1.5vw rgba(212, 160, 23, 0.5);
                -webkit-tap-highlight-color: transparent;
            }
            button:hover:not(:disabled) {
                box-shadow: 0 0 2vw #ffd700;
            }
            button:disabled {
                background: linear-gradient(#8b5a2b, #5c4033);
                cursor: not-allowed;
                opacity: 0.6;
            }
            #odds, #payouts {
                width: 85vw;
                margin: 5px auto;
                font-size: 2vw;
            }
            .odds-item, .payout-item {
                padding: 1vw;
                border: 0.3vw solid #d4a017;
                border-radius: 0.8vw;
                width: 14vw;
                font-size: 1.8vw;
                -webkit-user-select: none;
                -webkit-touch-callout: none;
                color: #d4a017 !important;
            }
            .payline {
                height: 1vw;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <h1>Dragon's Hoard Slot Machine</h1>
    <div id="slot-machine"></div>
    <div id="controls">
        <button id="spinButton" onclick="spin()">Spin (10 Coins)</button>
    </div>
    <div id="balance">Balance: 1000 Coins</div>
    <div id="result"></div>
    <div id="odds">
        <div class="odds-item">üëë 16.1%</div>
        <div class="odds-item">‚öîÔ∏è 16.1%</div>
        <div class="odds-item">üõ°Ô∏è 16.1%</div>
        <div class="odds-item">ü™ô 16.1%</div>
        <div class="odds-item">üêâ 12.9%</div>
        <div class="odds-item">‚ö∞Ô∏è 19.4%</div>
    </div>
    <div id="payouts">
        <div class="payout-item">4 Any: 50<br>1‚òÖ: 250<br>2‚òÖ: 1250</div>
        <div class="payout-item">5 üëë: 1000<br>1‚òÖ: 5000<br>2‚òÖ: 25000</div>
        <div class="payout-item">5 ‚öîÔ∏è/üõ°Ô∏è: 200<br>1‚òÖ: 1000<br>2‚òÖ: 5000</div>
        <div class="payout-item">Treasury: 150<br>1‚òÖ: 750<br>2‚òÖ: 3750</div>
        <div class="payout-item">Wheel: 50‚Äì500<br>1‚òÖ: <span class="no-link">250‚Äì2500</span><br>2‚òÖ: <span class="no-link">1250‚Äì12500</span></div>
    </div>

    <script>
        const symbols = ['üëë', '‚öîÔ∏è', 'üõ°Ô∏è', 'ü™ô', 'üêâ', '‚ö∞Ô∏è'];
        const weights = [5, 5, 5, 5, 4, 6];
        const nonBlankSymbols = ['üëë', '‚öîÔ∏è', 'üõ°Ô∏è', 'ü™ô', 'üêâ'];
        const nonBlankWeights = [5, 5, 5, 5, 4];
        const reels = Array(15).fill('');
        const jackpot = Array(15).fill(false);
        let balance = 1000;
        let isSpinning = false;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const spinButton = document.getElementById('spinButton');

        function playSpinSound() {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc1.type = 'sawtooth';
            osc2.type = 'triangle';
            osc1.frequency.value = 150;
            osc2.frequency.value = 800;
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            osc1.start();
            osc2.start();
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
            osc1.stop(audioCtx.currentTime + 1.5);
            osc2.stop(audioCtx.currentTime + 1.5);
        }

        function playBlankReplaceSound() {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc1.type = 'square';
            osc2.type = 'sine';
            osc1.frequency.value = 300;
            osc2.frequency.value = 1200;
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
            osc1.start();
            osc2.start(audioCtx.currentTime + 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
            osc1.stop(audioCtx.currentTime + 0.6);
            osc2.stop(audioCtx.currentTime + 0.6);
        }

        function playWinSound() {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc1.type = 'sine';
            osc2.type = 'triangle';
            osc1.frequency.value = 600;
            osc2.frequency.value = 900;
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            osc1.start();
            osc2.start(audioCtx.currentTime + 0.2);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
            osc1.stop(audioCtx.currentTime + 0.5);
            osc2.stop(audioCtx.currentTime + 0.5);
        }

        function playCoinBonusSound() {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc1.type = 'triangle';
            osc2.type = 'sine';
            osc1.frequency.value = 700;
            osc2.frequency.value = 1000;
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
            osc1.start();
            osc2.start();
            osc1.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.5);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.0);
            osc1.stop(audioCtx.currentTime + 1.0);
            osc2.stop(audioCtx.currentTime + 1.0);
        }

        function playDragonBonusSound() {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc1.type = 'sawtooth';
            osc2.type = 'sine';
            osc1.frequency.value = 100;
            osc2.frequency.value = 400;
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            osc1.start();
            osc2.start(audioCtx.currentTime + 0.3);
            osc1.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 1.5);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
            osc1.stop(audioCtx.currentTime + 1.5);
            osc2.stop(audioCtx.currentTime + 1.5);
        }

        function playBlessingSound() {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const osc3 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc1.type = 'sine';
            osc2.type = 'triangle';
            osc3.type = 'square';
            osc1.frequency.value = 800;
            osc2.frequency.value = 400;
            osc3.frequency.value = 1200;
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            osc3.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime);
            osc1.start();
            osc2.start(audioCtx.currentTime + 0.2);
            osc3.start(audioCtx.currentTime + 0.4);
            osc1.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 1.0);
            osc2.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 1.0);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2.0);
            osc1.stop(audioCtx.currentTime + 2.0);
            osc2.stop(audioCtx.currentTime + 2.0);
            osc3.stop(audioCtx.currentTime + 2.0);
        }

        const slotMachine = document.getElementById('slot-machine');
        for (let i = 0; i < 15; i++) {
            const reel = document.createElement('div');
            reel.className = 'reel';
            reel.id = `reel-${i}`;
            slotMachine.appendChild(reel);
        }

        function getRandomSymbol() {
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let rand = Math.random() * totalWeight;
            for (let i = 0; i < weights.length; i++) {
                rand -= weights[i];
                if (rand <= 0) return symbols[i];
            }
            return symbols[symbols.length - 1];
        }

        function getRandomNonBlankSymbol() {
            const totalWeight = nonBlankWeights.reduce((a, b) => a + b, 0);
            let rand = Math.random() * totalWeight;
            for (let i = 0; i < nonBlankWeights.length; i++) {
                rand -= nonBlankWeights[i];
                if (rand <= 0) return nonBlankSymbols[i];
            }
            return nonBlankSymbols[nonBlankWeights.length - 1];
        }

        function drawPayline(line, group) {
            console.log('Drawing payline for:', line, 'Group:', group);
            const isMobile = window.innerWidth <= 430;
            const reelWidth = isMobile ? 16 * window.innerWidth / 100 : 100;
            const reelHeight = isMobile ? 16 * window.innerWidth / 100 : 100;
            const gap = isMobile ? 1 * window.innerWidth / 100 : 5;
            const padding = isMobile ? 2 * window.innerWidth / 100 : 10;
            const border = isMobile ? 1.2 * window.innerWidth / 100 : 8;

            const horizontalLines = [
                [5, 6, 7, 8, 9],
                [0, 1, 2, 3, 4],
                [10, 11, 12, 13, 14]
            ];
            const isHorizontal = horizontalLines.some(h => JSON.stringify(h) === JSON.stringify(line));

            if (isHorizontal) {
                const paylineDiv = document.createElement('div');
                paylineDiv.className = 'payline';
                slotMachine.appendChild(paylineDiv);

                const startIdx = group[0];
                const startCol = startIdx % 5;
                const leftOffset = padding + border + startCol * (reelWidth + gap);
                const count = group.length;
                paylineDiv.style.left = `${leftOffset}px`;
                paylineDiv.style.width = `${count * reelWidth + (count - 1) * gap}px`;

                if (JSON.stringify(line) === JSON.stringify([5, 6, 7, 8, 9])) {
                    paylineDiv.style.top = `${padding + border + reelHeight + gap + reelHeight / 2}px`;
                } else if (JSON.stringify(line) === JSON.stringify([0, 1, 2, 3, 4])) {
                    paylineDiv.style.top = `${padding + border + reelHeight / 2}px`;
                } else if (JSON.stringify(line) === JSON.stringify([10, 11, 12, 13, 14])) {
                    paylineDiv.style.top = `${padding + border + 2 * (reelHeight + gap) + reelHeight / 2}px`;
                }

                setTimeout(() => {
                    paylineDiv.classList.add('fade-out');
                    setTimeout(() => paylineDiv.remove(), 300);
                }, 1200);
            } else {
                const limit = group.length - 1;
                for (let i = 0; i < limit; i++) {
                    const startIdx = group[i];
                    const endIdx = group[i + 1];
                    const startRow = Math.floor(startIdx / 5);
                    const startCol = startIdx % 5;
                    const endRow = Math.floor(endIdx / 5);
                    const endCol = endIdx % 5;

                    const startX = padding + border + startCol * (reelWidth + gap) + reelWidth / 2;
                    const startY = padding + border + startRow * (reelHeight + gap) + reelHeight / 2;
                    const endX = padding + border + endCol * (reelWidth + gap) + reelWidth / 2;
                    const endY = padding + border + endRow * (reelHeight + gap) + reelHeight / 2;

                    const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;

                    const paylineDiv = document.createElement('div');
                    paylineDiv.className = 'payline';
                    slotMachine.appendChild(paylineDiv);

                    paylineDiv.style.left = `${startX}px`;
                    paylineDiv.style.top = `${startY}px`;
                    paylineDiv.style.width = `${length}px`;
                    paylineDiv.style.transform = `rotate(${angle}deg)`;
                    paylineDiv.style.transformOrigin = 'left center';

                    setTimeout(() => {
                        paylineDiv.classList.add('fade-out');
                        setTimeout(() => paylineDiv.remove(), 300);
                    }, 1200);
                }
            }
        }

        async function spin() {
            if (isSpinning) return;
            isSpinning = true;
            spinButton.disabled = true;

            document.querySelectorAll('.payline').forEach(line => line.remove());

            if (balance < 10) {
                document.getElementById('result').innerText = 'Not enough coins!';
                isSpinning = false;
                spinButton.disabled = false;
                return;
            }
            balance -= 10;
            let winnings = 0;
            let resultText = '';
            let replacedIndices = new Set();

            playSpinSound();

            const isFullBoardBonus = Math.random() < 0.01;
            if (isFullBoardBonus) {
                const bonusSymbol = nonBlankSymbols[Math.floor(Math.random() * nonBlankSymbols.length)];
                for (let i = 0; i < 15; i++) {
                    const reelElement = document.getElementById(`reel-${i}`);
                    reelElement.classList.add('spinning');
                    let cycleCount = 0;
                    const cycleInterval = setInterval(() => {
                        reelElement.innerText = getRandomSymbol();
                        cycleCount++;
                        if (cycleCount > 50) clearInterval(cycleInterval);
                    }, 50);
                    reelElement.dataset.interval = cycleInterval;
                }

                for (let col = 0; col < 5; col++) {
                    const indices = [col, col + 5, col + 10];
                    for (const i of indices) {
                        reels[i] = bonusSymbol;
                        jackpot[i] = false;
                        const reelElement = document.getElementById(`reel-${i}`);
                        clearInterval(reelElement.dataset.interval);
                        reelElement.classList.remove('spinning');
                        if (reels[i] === 'üõ°Ô∏è') {
                            reelElement.innerHTML = '<span>' + reels[i] + '</span>';
                            reelElement.classList.add('shield');
                        } else {
                            reelElement.innerText = reels[i];
                            reelElement.classList.remove('shield');
                        }
                        reelElement.classList.remove('jackpot');
                    }
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                winnings += 10000;
                resultText = `Dragon‚Äôs Blessing! All ${bonusSymbol} board! +10000 coins! `;
                playBlessingSound();
                balance += winnings;
                document.getElementById('balance').innerText = `Balance: ${balance} Coins`;
                document.getElementById('result').innerText = `Won ${winnings} coins! ${resultText}`;
                isSpinning = false;
                spinButton.disabled = false;
                return;
            }

            for (let i = 0; i < 15; i++) {
                const reelElement = document.getElementById(`reel-${i}`);
                reelElement.classList.add('spinning');
                let cycleCount = 0;
                const cycleInterval = setInterval(() => {
                    reelElement.innerText = getRandomSymbol();
                    cycleCount++;
                    if (cycleCount > 50) clearInterval(cycleInterval);
                }, 50);
                reelElement.dataset.interval = cycleInterval;
            }

            for (let col = 0; col < 5; col++) {
                const indices = [col, col + 5, col + 10];
                for (const i of indices) {
                    reels[i] = getRandomSymbol();
                    jackpot[i] = Math.random() < 0.10 && reels[i] !== '‚ö∞Ô∏è';
                    const reelElement = document.getElementById(`reel-${i}`);
                    clearInterval(reelElement.dataset.interval);
                    reelElement.classList.remove('spinning');
                    if (reels[i] === 'üõ°Ô∏è') {
                        reelElement.innerHTML = '<span>' + reels[i] + '</span>';
                        reelElement.classList.add('shield');
                    } else {
                        reelElement.innerText = reels[i];
                        reelElement.classList.remove('shield');
                    }
                    if (jackpot[i]) reelElement.classList.add('jackpot');
                    else reelElement.classList.remove('jackpot');
                }
                await new Promise(resolve => setTimeout(resolve, 300));
            }

            const blankGroups = [];
            for (let row = 0; row < 3; row++) {
                let start = row * 5;
                let count = 0;
                let group = [];
                for (let col = 0; col < 5; col++) {
                    let i = start + col;
                    if (reels[i] === '‚ö∞Ô∏è') {
                        count++;
                        group.push(i);
                    } else {
                        if (count >= 4) blankGroups.push(group);
                        count = 0;
                        group = [];
                    }
                }
                if (count >= 4) blankGroups.push(group);
            }

            if (blankGroups.length > 0) {
                resultText += '4+ Adjacent Blanks! Replacing... ';
                playBlankReplaceSound();
                for (let group of blankGroups) {
                    for (let i of group) {
                        const reelElement = document.getElementById(`reel-${i}`);
                        reelElement.classList.add('blank-replace');
                        await new Promise(resolve => setTimeout(resolve, 600));
                        reels[i] = getRandomNonBlankSymbol();
                        jackpot[i] = Math.random() < 0.10;
                        if (reels[i] === 'üõ°Ô∏è') {
                            reelElement.innerHTML = '<span>' + reels[i] + '</span>';
                            reelElement.classList.add('shield');
                        } else {
                            reelElement.innerText = reels[i];
                            reelElement.classList.remove('shield');
                        }
                        if (jackpot[i]) reelElement.classList.add('jackpot');
                        else reelElement.classList.remove('jackpot');
                        reelElement.classList.remove('blank-replace');
                        replacedIndices.add(i);
                    }
                }
            }

            const paylines = [
                [5, 6, 7, 8, 9],
                [0, 1, 2, 3, 4],
                [10, 11, 12, 13, 14],
                [0, 6, 12, 8, 4],
                [10, 6, 2, 8, 14]
            ];

            let winningGroups = [];
            let bonusGroups = [];
            let initialReplacementDone = false;

            for (let line of paylines) {
                let count = 0;
                let wilds = 0;
                let jackpotCount = 0;
                let maxSymbol = null;
                let group = [];

                for (let i = 0; i < line.length; i++) {
                    let curr = reels[line[i]];
                    if (curr === 'üêâ') {
                        wilds++;
                        group.push(line[i]);
                        if (maxSymbol === null && i > 0) maxSymbol = reels[line[i - 1]];
                        if (jackpot[line[i]]) jackpotCount++;
                    } else if (curr !== '‚ö∞Ô∏è' && (maxSymbol === null || curr === maxSymbol)) {
                        count++;
                        group.push(line[i]);
                        if (maxSymbol === null) maxSymbol = curr;
                        if (jackpot[line[i]]) jackpotCount++;
                    } else {
                        if (count + wilds >= 4) break;
                        count = 0;
                        wilds = 0;
                        jackpotCount = 0;
                        maxSymbol = null;
                        group = [];
                        if (curr !== '‚ö∞Ô∏è') {
                            count = 1;
                            group = [line[i]];
                            maxSymbol = curr;
                            if (jackpot[line[i]]) jackpotCount++;
                        }
                    }
                }

                let effectiveCount = count + wilds;
                if (effectiveCount >= 4 && maxSymbol !== null) {
                    group.forEach(i => document.getElementById(`reel-${i}`).classList.add('win'));
                    drawPayline(line, group); // Pass group instead of effectiveCount
                    playWinSound();
                    let lineWinnings = 0;
                    if (effectiveCount >= 5) {
                        if (maxSymbol === 'üëë') lineWinnings = 100 * 10;
                        else if (maxSymbol === '‚öîÔ∏è' || maxSymbol === 'üõ°Ô∏è') lineWinnings = 20 * 10;
                        else if (maxSymbol === 'ü™ô') lineWinnings = 10 * 10;
                        resultText += `5 ${maxSymbol} in a row! `;
                    } else {
                        lineWinnings = 5 * 10;
                        resultText += `4 ${maxSymbol} in a row! `;
                    }
                    if (jackpotCount > 0) {
                        const multiplier = Math.pow(5, jackpotCount);
                        lineWinnings *= multiplier;
                        resultText += `Jackpot ${jackpotCount}x (${multiplier}x multiplier)! `;
                    }
                    winnings += lineWinnings;
                    winningGroups.push(group);
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    group.forEach(i => document.getElementById(`reel-${i}`).classList.remove('win'));
                }
            }

            for (let line of paylines) {
                let coinCount = 0;
                let dragonCount = 0;
                let coinJackpotCount = 0;
                let dragonJackpotCount = 0;
                let coinGroup = [];
                let dragonGroup = [];

                for (let i = 0; i < line.length; i++) {
                    let curr = reels[line[i]];
                    if (curr === 'ü™ô' || curr === 'üêâ') {
                        coinCount++;
                        coinGroup.push(line[i]);
                        if (jackpot[line[i]]) coinJackpotCount++;
                    } else {
                        if (coinCount >= 4) break;
                        coinCount = 0;
                        coinJackpotCount = 0;
                        coinGroup = [];
                    }
                    if (curr === 'üêâ') {
                        dragonCount++;
                        dragonGroup.push(line[i]);
                        if (jackpot[line[i]]) dragonJackpotCount++;
                    } else {
                        if (dragonCount >= 4) break;
                        dragonCount = 0;
                        dragonJackpotCount = 0;
                        dragonGroup = [];
                    }
                }

                if (coinCount >= 4) {
                    drawPayline(line, coinGroup);
                    let coinWinnings = 10 * 10;
                    if (coinJackpotCount > 0) {
                        const multiplier = Math.pow(5, coinJackpotCount);
                        coinWinnings += 50 * multiplier;
                        resultText += `5 Coins in a row! Treasury Spin: +${coinWinnings} coins (${coinJackpotCount}x Jackpot, ${multiplier}x)! `;
                    } else {
                        coinWinnings += 50;
                        resultText += `5 Coins in a row! Treasury Spin: +${coinWinnings} coins! `;
                    }
                    winnings += coinWinnings;
                    playCoinBonusSound();
                    bonusGroups.push(coinGroup);
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
                if (dragonCount >= 4) {
                    drawPayline(line, dragonGroup);
                    const multiplier = Math.floor(Math.random() * 46) + 5;
                    let dragonWinnings = 10 * multiplier;
                    if (dragonJackpotCount > 0) {
                        const jackpotMultiplier = Math.pow(5, dragonJackpotCount);
                        dragonWinnings *= jackpotMultiplier;
                        resultText += `5 Dragons in a row! Dragon‚Äôs Wheel: ${multiplier}x (${dragonJackpotCount}x Jackpot, ${jackpotMultiplier}x) = ${dragonWinnings} coins! `;
                    } else {
                        resultText += `5 Dragons in a row! Dragon‚Äôs Wheel: ${multiplier}x = ${dragonWinnings} coins! `;
                    }
                    winnings += dragonWinnings;
                    playDragonBonusSound();
                    bonusGroups.push(dragonGroup);
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }

            const allWinningGroups = [...winningGroups, ...bonusGroups];
            if (allWinningGroups.length > 0 && !initialReplacementDone) {
                resultText += 'Winning emojis replaced! ';
                playBlankReplaceSound();
                for (let group of allWinningGroups) {
                    for (let i of group) {
                        if (!replacedIndices.has(i)) {
                            const reelElement = document.getElementById(`reel-${i}`);
                            reelElement.classList.add('win-replace');
                            await new Promise(resolve => setTimeout(resolve, 600));
                            reels[i] = getRandomNonBlankSymbol();
                            jackpot[i] = Math.random() < 0.10;
                            if (reels[i] === 'üõ°Ô∏è') {
                                reelElement.innerHTML = '<span>' + reels[i] + '</span>';
                                reelElement.classList.add('shield');
                            } else {
                                reelElement.innerText = reels[i];
                                reelElement.classList.remove('shield');
                            }
                            if (jackpot[i]) reelElement.classList.add('jackpot');
                            else reelElement.classList.remove('jackpot');
                            reelElement.classList.remove('win-replace');
                            replacedIndices.add(i);
                        }
                    }
                }
                initialReplacementDone = true;

                winningGroups = [];
                bonusGroups = [];

                for (let line of paylines) {
                    let count = 0;
                    let wilds = 0;
                    let jackpotCount = 0;
                    let maxSymbol = null;
                    let group = [];

                    for (let i = 0; i < line.length; i++) {
                        let curr = reels[line[i]];
                        if (curr === 'üêâ') {
                            wilds++;
                            group.push(line[i]);
                            if (maxSymbol === null && i > 0) maxSymbol = reels[line[i - 1]];
                            if (jackpot[line[i]]) jackpotCount++;
                        } else if (curr !== '‚ö∞Ô∏è' && (maxSymbol === null || curr === maxSymbol)) {
                            count++;
                            group.push(line[i]);
                            if (maxSymbol === null) maxSymbol = curr;
                            if (jackpot[line[i]]) jackpotCount++;
                        } else {
                            if (count + wilds >= 4) break;
                            count = 0;
                            wilds = 0;
                            jackpotCount = 0;
                            maxSymbol = null;
                            group = [];
                            if (curr !== '‚ö∞Ô∏è') {
                                count = 1;
                                group = [line[i]];
                                maxSymbol = curr;
                                if (jackpot[line[i]]) jackpotCount++;
                            }
                        }
                    }

                    let effectiveCount = count + wilds;
                    if (effectiveCount >= 4 && maxSymbol !== null) {
                        group.forEach(i => document.getElementById(`reel-${i}`).classList.add('win'));
                        drawPayline(line, group);
                        playWinSound();
                        let lineWinnings = 0;
                        if (effectiveCount >= 5) {
                            if (maxSymbol === 'üëë') lineWinnings = 100 * 10;
                            else if (maxSymbol === '‚öîÔ∏è' || maxSymbol === 'üõ°Ô∏è') lineWinnings = 20 * 10;
                            else if (maxSymbol === 'ü™ô') lineWinnings = 10 * 10;
                            resultText += `5 ${maxSymbol} in a row! `;
                        } else {
                            lineWinnings = 5 * 10;
                            resultText += `4 ${maxSymbol} in a row! `;
                        }
                        if (jackpotCount > 0) {
                            const multiplier = Math.pow(5, jackpotCount);
                            lineWinnings *= multiplier;
                            resultText += `Jackpot ${jackpotCount}x (${multiplier}x multiplier)! `;
                        }
                        winnings += lineWinnings;
                        winningGroups.push(group);
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        group.forEach(i => document.getElementById(`reel-${i}`).classList.remove('win'));
                    }
                }

                for (let line of paylines) {
                    let coinCount = 0;
                    let dragonCount = 0;
                    let coinJackpotCount = 0;
                    let dragonJackpotCount = 0;
                    let coinGroup = [];
                    let dragonGroup = [];

                    for (let i = 0; i < line.length; i++) {
                        let curr = reels[line[i]];
                        if (curr === 'ü™ô' || curr === 'üêâ') {
                            coinCount++;
                            coinGroup.push(line[i]);
                            if (jackpot[line[i]]) coinJackpotCount++;
                        } else {
                            if (coinCount >= 4) break;
                            coinCount = 0;
                            coinJackpotCount = 0;
                            coinGroup = [];
                        }
                        if (curr === 'üêâ') {
                            dragonCount++;
                            dragonGroup.push(line[i]);
                            if (jackpot[line[i]]) dragonJackpotCount++;
                        } else {
                            if (dragonCount >= 4) break;
                            dragonCount = 0;
                            dragonJackpotCount = 0;
                            dragonGroup = [];
                        }
                    }

                    if (coinCount >= 4) {
                        drawPayline(line, coinGroup);
                        let coinWinnings = 10 * 10;
                        if (coinJackpotCount > 0) {
                            const multiplier = Math.pow(5, coinJackpotCount);
                            coinWinnings += 50 * multiplier;
                            resultText += `5 Coins in a row! Treasury Spin: +${coinWinnings} coins (${coinJackpotCount}x Jackpot, ${multiplier}x)! `;
                        } else {
                            coinWinnings += 50;
                            resultText += `5 Coins in a row! Treasury Spin: +${coinWinnings} coins! `;
                        }
                        winnings += coinWinnings;
                        playCoinBonusSound();
                        bonusGroups.push(coinGroup);
                        await new Promise(resolve => setTimeout(resolve, 1500));
                    }
                    if (dragonCount >= 4) {
                        drawPayline(line, dragonGroup);
                        const multiplier = Math.floor(Math.random() * 46) + 5;
                        let dragonWinnings = 10 * multiplier;
                        if (dragonJackpotCount > 0) {
                            const jackpotMultiplier = Math.pow(5, dragonJackpotCount);
                            dragonWinnings *= jackpotMultiplier;
                            resultText += `5 Dragons in a row! Dragon‚Äôs Wheel: ${multiplier}x (${dragonJackpotCount}x Jackpot, ${jackpotMultiplier}x) = ${dragonWinnings} coins! `;
                        } else {
                            resultText += `5 Dragons in a row! Dragon‚Äôs Wheel: ${multiplier}x = ${dragonWinnings} coins! `;
                        }
                        winnings += dragonWinnings;
                        playDragonBonusSound();
                        bonusGroups.push(dragonGroup);
                        await new Promise(resolve => setTimeout(resolve, 1500));
                    }
                }
            }

            balance += winnings;
            document.getElementById('balance').innerText = `Balance: ${balance} Coins`;
            document.getElementById('result').innerText = winnings > 0 ? `Won ${winnings} coins! ${resultText}` : 'No win this time.';
            isSpinning = false;
            spinButton.disabled = false;
        }
    </script>
</body>
</html>
